import os
import json
import tempfile
from flask import Flask, request, jsonify, send_file,render_template
from flask_cors import CORS
from werkzeug.utils import secure_filename
import google.generativeai as genai
from PyPDF2 import PdfReader
import io
from fpdf import FPDF
from datetime import datetime
import re

app = Flask(__name__)
CORS(app)

# Load environment variables
from dotenv import load_dotenv
load_dotenv()

# Configure Gemini API
genai.configure(api_key=os.getenv('AIzaSyDMLM2sdSUYE5Lsrv_XoaMJwXnT2izEuxs'))
model = genai.GenerativeModel('gemini-1.5-flash')

# Configuration
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size
UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'pdf'}

# Ensure upload folder exists
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def extract_text_from_pdf(file):
    """Extract text content from uploaded PDF file"""
    try:
        pdf_reader = PdfReader(file)
        text = ""
        for page in pdf_reader.pages:
            text += page.extract_text() + "\n"
        return text.strip()
    except Exception as e:
        raise Exception(f"Error reading PDF: {str(e)}")

def create_mcq_prompt(content, num_questions, difficulty):
    """Create a structured prompt for Gemini API to generate MCQs"""
    
    difficulty_instructions = {
        "easy": "Generate easy-level questions that test basic understanding and recall of fundamental concepts.",
        "medium": "Generate medium-level questions that require application of concepts and moderate analysis.",
        "hard": "Generate hard-level questions that require critical thinking, synthesis, and deep understanding.",
        "mixed": "Generate a mix of easy, medium, and hard questions with varying difficulty levels."
    }
    
    prompt = f"""
You are an expert educator and question creator. Based on the following content, create {num_questions} multiple-choice questions (MCQs).

DIFFICULTY LEVEL: {difficulty.upper()}
{difficulty_instructions[difficulty]}

CONTENT TO ANALYZE:
{content[:8000]}  # Limit content to avoid token limits

REQUIREMENTS:
1. Generate EXACTLY {num_questions} multiple-choice questions
2. Each question should have 4 options (A, B, C, D)
3. Provide the correct answer
4. Include a brief explanation for the correct answer
5. Tag each question with the relevant topic from the content
6. Ensure questions are well-distributed across different topics in the content
7. Make questions clear, unambiguous, and educational

OUTPUT FORMAT (JSON):
{{
    "questions": [
        {{
            "id": 1,
            "question": "Question text here?",
            "options": {{
                "A": "Option A text",
                "B": "Option B text", 
                "C": "Option C text",
                "D": "Option D text"
            }},
            "correct_answer": "A",
            "explanation": "Brief explanation why this answer is correct",
            "topic": "Specific topic this question relates to",
            "difficulty": "easy/medium/hard"
        }}
    ]
}}

Generate diverse, high-quality questions that effectively test understanding of the material.
"""
    return prompt

def parse_gemini_response(response_text):
    """Parse and validate Gemini API response"""
    try:
        # Try to extract JSON from the response
        json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
        if json_match:
            json_str = json_match.group()
            data = json.loads(json_str)
            return data
        else:
            raise ValueError("No JSON found in response")
    except json.JSONDecodeError:
        # Fallback: try to parse response manually if JSON parsing fails
        return {"error": "Failed to parse response", "raw_response": response_text}

def generate_pdf_report(mcq_data, filename_prefix="MCQ_Report"):
    """Generate PDF report with MCQs"""
    class PDF(FPDF):
        def header(self):
            self.set_font('Arial', 'B', 16)
            self.cell(0, 10, 'MCQ Report - Generated by QuesThink', 0, 1, 'C')
            self.ln(5)
        
        def footer(self):
            self.set_y(-15)
            self.set_font('Arial', 'I', 8)
            self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'C')

    pdf = PDF()
    pdf.add_page()
    pdf.set_font('Arial', '', 12)
    
    # Add generation info
    pdf.cell(0, 10, f'Generated on: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}', 0, 1)
    pdf.cell(0, 10, f'Total Questions: {len(mcq_data.get("questions", []))}', 0, 1)
    pdf.ln(10)
    
    # Add questions
    for i, q in enumerate(mcq_data.get("questions", []), 1):
        # Question
        pdf.set_font('Arial', 'B', 12)
        pdf.cell(0, 10, f'Q{i}. {q.get("question", "")}', 0, 1)
        pdf.ln(2)
        
        # Topic and Difficulty
        pdf.set_font('Arial', 'I', 10)
        pdf.cell(0, 8, f'Topic: {q.get("topic", "N/A")} | Difficulty: {q.get("difficulty", "N/A")}', 0, 1)
        pdf.ln(2)
        
        # Options
        pdf.set_font('Arial', '', 11)
        for option, text in q.get("options", {}).items():
            prefix = f'{option}) '
            if option == q.get("correct_answer"):
                pdf.set_font('Arial', 'B', 11)  # Bold for correct answer
            else:
                pdf.set_font('Arial', '', 11)
            pdf.cell(0, 7, f'{prefix}{text}', 0, 1)
        
        # Explanation
        pdf.ln(2)
        pdf.set_font('Arial', '', 10)
        pdf.multi_cell(0, 6, f'Explanation: {q.get("explanation", "No explanation provided")}')
        pdf.ln(8)
        
        # Page break if needed
        if pdf.get_y() > 250:
            pdf.add_page()
    
    # Save PDF to bytes
    pdf_output = io.BytesIO()
    pdf_content = pdf.output(dest='S').encode('latin-1')
    pdf_output.write(pdf_content)
    pdf_output.seek(0)
    
    return pdf_output



@app.route('/', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        "status": "success",
        "message": "QuesThink MCQ Generator Backend is running!",
        "version": "1.0.0"
    })

@app.route('/generate-mcq', methods=['POST'])
def generate_mcq():
    """Main endpoint to generate MCQs from PDF"""
    try:
        # Validate request
        if 'pdf_file' not in request.files:
            return jsonify({"error": "No PDF file uploaded"}), 400
        
        file = request.files['pdf_file']
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
        
        if not allowed_file(file.filename):
            return jsonify({"error": "Invalid file type. Please upload a PDF file"}), 400
        
        # Get parameters
        num_questions = int(request.form.get('num_questions', 10))
        difficulty = request.form.get('difficulty', 'medium').lower()
        
        # Validate parameters
        if num_questions < 5 or num_questions > 50:
            return jsonify({"error": "Number of questions must be between 5 and 50"}), 400
        
        if difficulty not in ['easy', 'medium', 'hard', 'mixed']:
            return jsonify({"error": "Invalid difficulty level"}), 400
        
        # Extract text from PDF
        try:
            pdf_text = extract_text_from_pdf(file)
            if len(pdf_text.strip()) < 100:
                return jsonify({"error": "PDF content is too short or could not be extracted"}), 400
        except Exception as e:
            return jsonify({"error": f"Error processing PDF: {str(e)}"}), 400
        
        # Generate MCQs using Gemini
        try:
            prompt = create_mcq_prompt(pdf_text, num_questions, difficulty)
            response = model.generate_content(prompt)
            
            if not response.text:
                return jsonify({"error": "No response from AI model"}), 500
            
            # Parse response
            mcq_data = parse_gemini_response(response.text)
            
            if "error" in mcq_data:
                return jsonify({
                    "error": "Failed to generate properly formatted MCQs",
                    "details": mcq_data.get("raw_response", "")
                }), 500
            
            # Validate generated questions
            questions = mcq_data.get("questions", [])
            if len(questions) == 0:
                return jsonify({"error": "No questions were generated"}), 500
            
            # Add metadata
            result = {
                "success": True,
                "data": {
                    "questions": questions,
                    "metadata": {
                        "total_questions": len(questions),
                        "difficulty": difficulty,
                        "generated_at": datetime.now().isoformat(),
                        "source": "PDF Upload"
                    }
                }
            }
            
            return jsonify(result)
            
        except Exception as e:
            return jsonify({"error": f"Error generating MCQs: {str(e)}"}), 500
    
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

@app.route('/download-pdf', methods=['POST'])
def download_pdf():
    """Generate and download PDF report of MCQs"""
    try:
        mcq_data = request.json
        
        if not mcq_data or 'questions' not in mcq_data:
            return jsonify({"error": "Invalid MCQ data provided"}), 400
        
        # Generate PDF
        pdf_buffer = generate_pdf_report(mcq_data)
        
        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"MCQ_Report_{timestamp}.pdf"
        
        return send_file(
            pdf_buffer,
            as_attachment=True,
            download_name=filename,
            mimetype='application/pdf'
        )
    
    except Exception as e:
        return jsonify({"error": f"Error generating PDF: {str(e)}"}), 500

@app.route('/export-json', methods=['POST'])
def export_json():
    """Export MCQs as JSON file"""
    try:
        mcq_data = request.json
        
        if not mcq_data:
            return jsonify({"error": "No data provided"}), 400
        
        # Add export metadata
        export_data = {
            "export_info": {
                "exported_at": datetime.now().isoformat(),
                "format": "JSON",
                "generator": "QuesThink MCQ Generator"
            },
            "mcq_data": mcq_data
        }
        
        # Create JSON file in memory
        json_buffer = io.BytesIO()
        json_str = json.dumps(export_data, indent=2, ensure_ascii=False)
        json_buffer.write(json_str.encode('utf-8'))
        json_buffer.seek(0)
        
        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"MCQ_Data_{timestamp}.json"
        
        return send_file(
            json_buffer,
            as_attachment=True,
            download_name=filename,
            mimetype='application/json'
        )
    
    except Exception as e:
        return jsonify({"error": f"Error exporting JSON: {str(e)}"}), 500

@app.errorhandler(413)
def too_large(e):
    return jsonify({"error": "File too large. Maximum size is 16MB"}), 413

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

@app.route('/ui')
def serve_ui():
    return render_template("index.html","style.css", "script.js")

if __name__ == '__main__':
    print("ðŸ§  QuesThink MCQ Generator Backend Starting...")
    print("ðŸ“š Ready to generate intelligent MCQs from your PDFs!")
    print("ðŸŒ Access the API at: http://localhost:5000")
    app.run(debug=True, host='0.0.0.0', port=5000)